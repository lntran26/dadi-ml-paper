import pickle
from matplotlib import pyplot as plt
from mapie.metrics import regression_coverage_score
import numpy as np
from sklearn.metrics import r2_score
from scipy import stats


params = [r'$ν_1$', r'$ν_2$', 'T', 'm', "misid"]
logs = [True, True, False, False, False]
theta_list = [1, 10000, 1000, 100]
alpha = [.05, .1, .2, .5, .7, .85]
plot_prefix = 'plots/noise/'

# load test data
list_test_dict = []
for theta in theta_list:
    list_test_dict.append(pickle.load(open(f'data/test_100_theta_{theta}','rb')))
    
# load trained models
list_mlpr = []
for theta in theta_list:
    pred_list = []
    for i in ['01', '02', '03', '04', '05']:
        mlpr = pickle.load(
            open(f'tuned_models_{theta}/param_{i}_predictor', 'rb'))
        pred_list.append(mlpr)
    list_mlpr.append(pred_list)
    
def prep_data(data: dict, mapie=True):
    '''
    Helper method for outputing X and y from input data dict
    Input: data dict generated by generate_fs() method
    Output: X_input as a list of flattened fs datasets
            y_label_unpack as a list of list, where each inner list
            is the label of one single demographic param if mapie,
            If mapie=False, y_label_unpack will be a list of one list,
            with this one inner list containing tuples of all dem params.
    '''
    X_input = [np.array(fs).flatten() for fs in data.values()]
    y_label = list(data.keys())
    # parse labels into single list for each param (required for mapie)
    y_label_unpack = list(zip(*y_label)) if mapie else [y_label]

    return X_input, y_label_unpack
    
def prep_fs_for_ml(input_fs):
    '''normalize and set masked entries to zeros
    input_fs: single Spectrum object from which to generate prediction'''
    # make sure the input_fs is normalized
    if round(input_fs.sum(), 3) != float(1):
        input_fs = input_fs/input_fs.sum()
    # assign zeros to masked entries of fs
    input_fs.flat[0] = 0
    input_fs.flat[-1] = 0

    return input_fs
    
def plot_accuracy_single(x, y, size=(8, 2, 20), x_label="True",
                         y_label="MLPR inferred", log=False,
                         r2=None, rho=None, c=None, title=None, subtitle=None):
    '''
    Plot a single x vs. y scatter plot panel, with correlation scores

    x, y = lists of x and y values to be plotted, e.g. true, pred
    size = [dots_size, line_width, font_size],
        e.g size = [8,2,20] for 4x4, size= [20,4,40] for 2x2
    log: if true will plot in log scale
    r2: r2 score for x and y
    msle: msle score for x and y (x, y need to be non-log, i.e. non-neg)
    rho: rho score for x and y
    c: if true will plot data points in a color range with color bar
    '''

    ax = plt.gca()
    # make square plots with two axes the same size
    ax.set_aspect('equal', 'box')
    # plot data points in a scatter plot
    if c is None:
        plt.scatter(x, y, s=size[0]*2**3, alpha=0.8)  # 's' specifies dots size
    else:  # condition to add color bar
        plt.scatter(x, y, c=c, vmax=5, s=size[0]*2**3)  # vmax: colorbar limit

    # axis label texts
    plt.xlabel(x_label, fontsize=size[2], labelpad=size[2]/2)
    plt.ylabel(y_label, fontsize=size[2], labelpad=size[2]/2)

    # only plot in log scale if log specified for the param
    if log:
        plt.xscale("log")
        plt.yscale("log")
        # axis scales customized to data
        plt.xlim([min(x+y)*10**-0.5, max(x+y)*10**0.5])
        plt.ylim([min(x+y)*10**-0.5, max(x+y)*10**0.5])
        plt.xticks(ticks=[1e-2, 1e0, 1e2])
        plt.yticks(ticks=[1e-2, 1e0, 1e2])
        plt.minorticks_off()
    else:
        # axis scales customized to data
        if max(x+y) > 1:
            plt.xlim([min(x+y)-0.5, max(x+y)+0.5])
            plt.ylim([min(x+y)-0.5, max(x+y)+0.5])
            # plt.xlim([min(x+y)-0.5, max(x+y)+0.5])
            # plt.ylim([min(x+y)-0.5, max(x+y)+0.5])
            # plt.xticks(ticks=[i for i in range(0, int(max(x+y)+1.5))])
            # plt.yticks(ticks=[i for i in range(0, int(max(x+y)+1.5))])
        else:
            plt.xlim([min(x+y)-0.05, max(x+y)+0.05])
            plt.ylim([min(x+y)-0.05, max(x+y)+0.05])
            # plt.xlim([min(x+y)-1, max(x+y)+1])
            # plt.ylim([min(x+y)-1, max(x+y)+1])
            # plt.xticks(ticks=[i for i in range(0, int(max(x+y)+1.5), 5)])
            # plt.yticks(ticks=[i for i in range(0, int(max(x+y)+1.5), 5)])
    plt.tick_params('both', length=size[2]/2, which='major')

    # plot a line of slope 1 (perfect correlation)
    plt.axline((0, 0), (1, 1), linewidth=size[1]/2, color='black', zorder=-100)

    # plot scores if specified
    if rho is not None:
        plt.text(0.3, 0.82, "ρ: " + str(round(rho, 4)),
                 horizontalalignment='center', verticalalignment='center',
                 fontsize=size[2], transform=ax.transAxes)
    if title is not None:
        ax.text(0.05,0.98,title, transform=ax.transAxes, va='top', fontsize=size[2])
    if subtitle != None:
        ax.set_title(subtitle, fontsize=size[2])
    plt.rc('xtick', labelsize=size[2])
    plt.rc('ytick', labelsize=size[2])
    plt.tight_layout()
    
def plot_coverage(cov_scores, alpha, title=None, params=None):
    """Helper method to plot coverage plot"""

    expected = [100*(1 - a) for a in alpha]
    observed = []
    for cov_score in cov_scores:
        observed.append([s*100 for s in cov_score])

    ax = plt.gca()
    ax.set_aspect('equal', 'box')

    ax.set_title(title, fontsize=22)
    # ax.set_xlabel('Expected', fontsize=20, labelpad=10)
    # ax.set_ylabel('Observed', fontsize=20)

    for i in range(len(cov_scores)):
        label = params[i] if params is not None else 'param '+str(i+1)
        ax.plot(expected, observed[i],
                label=label, linewidth=1.5)
    ax.plot([0,100], [0,100], '-k', zorder=-100, lw=1)
    # define axis range
    plt.xlim([0, 100])
    plt.ylim([0, 100])
    # define ticks
    plt.xticks(ticks=[i for i in range(0, 101, 25)])
    plt.yticks(ticks=[i for i in range(0, 101, 25)])
    plt.tick_params(length=10, which='major')
    plt.rc('xtick', labelsize=26)
    plt.rc('ytick', labelsize=26)
    # ax.legend(loc='upper left', fontsize=8)
    ax.legend(fontsize=18, frameon=False, loc='upper left')
    plt.tight_layout(pad=0.6, h_pad=0)
    
for i, test_dict in enumerate(list_test_dict):
    # each test theta case, i is test theta count
    prep_test_dict = {}
    for params_key in test_dict:
        prep_test_dict[params_key] = prep_fs_for_ml(test_dict[params_key])
    X_test, y_test = prep_data(prep_test_dict, mapie=True)
    
    for j, mlpr_list in enumerate(list_mlpr): # mlpr_list is the mlpr for all param of one theta
        # j is train theta count
        all_coverage = []
        for model_i, model in enumerate(mlpr_list): # each demo param
            font = {'size': 20}
            plt.rc('font', **font)
            plt.figure(model_i+1, figsize=(20, 18))
            plt.figure(model_i+1).add_subplot(4, 4, i+j*4+1)
            true = y_test[model_i]
            pred, pis = model.predict(X_test, alpha=alpha)
            coverage_scores = [
                regression_coverage_score(true, pis[:, 0, i], pis[:, 1, i])
                for i, _ in enumerate(alpha)]
            all_coverage.append(coverage_scores)
            if logs[model_i]:
                true_delog = [10**p_true for p_true in true]
                pred_delog = [10**p_pred for p_pred in pred]
                # r2 = r2_score(true_delog, pred_delog)
                rho = stats.spearmanr(true_delog, pred_delog)[0]
                plot_accuracy_single(true_delog, pred_delog, size=[6, 2, 26],
                                     log=True, rho=rho,
                                     x_label="",y_label="",
                                     title=f"{params[model_i]}",
                                     # subtitle=f"train θ={theta_list[j]}\ntest θ={theta_list[i]}"
                                     )
            else:
                rho = stats.spearmanr(true, pred)[0]
                plot_accuracy_single(list(true), list(pred),
                                     log=False,
                                     rho=rho, size=[6, 2, 26],
                                     x_label="",y_label="",
                                     title=f"{params[model_i]}",
                                     # subtitle=f"train θ={theta_list[j]}\ntest θ={theta_list[i]}"
                                     )
            plt.savefig(f"{plot_prefix}{params[model_i]}.png", transparent=True, dpi=150)
            plt.savefig(f"{plot_prefix}{params[model_i]}.svg", transparent=True, dpi=150)
        
        plt.figure(6, figsize=(20, 19))
        plt.figure(6).add_subplot(4, 4, i+j*4+1)
        plot_coverage(all_coverage, alpha, 
                    # title=f"train θ={theta_list[j]}\ntest θ={theta_list[i]}",
                    params=params)
        plt.savefig(f"{plot_prefix}coverage.png", transparent=True, dpi=150)
        plt.savefig(f"{plot_prefix}coverage.svg", transparent=True, dpi=150)
                    